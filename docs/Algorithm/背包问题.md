# 我对背包问题理解

## 背包问题

背包问题是经典的考察动态规划应用的题目，对其加上不同的限制和条件，可以衍生出诸多变种，若要全面理解动态规划，掌握背包问题是必不可少的。由于本人水平有限，本文只是作者对背包问题的理解，如有不正确之处还请谅解和指正。

**题目描述**

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

所有背包问题的主干与题目描述中的一致，但是加上不同的条件限制后，会形成各种背包问题的变种。下文是作者对0-1背包和完全背包问题的理解笔记。为啥只有这两种，水平实在有限。

## 0-1背包问题

0-1背包问题是最基础的背包问题，顾名思义0-1背包即每种的物品仅有一件，那么对于指定的物品的选择只有取或者不取两种状态。现在我们定义一个状态`F[i][v]`用来表示可选择的物品范围为前i件物品并且所有物品的体积总和不超过v时，背包内所有物品的价值总和最大。那么，`F[i][v]`则可以通过以下两种状态转移得到：

- 如果不选第i件物品，那么最大价值总和为取前i-1件物品且背包容量不超过v时的最大价值，即`F[i][v] = F[i-1][v]`
- 如果选择第i件物品，那么最大价值总和为取前i-1件物品且背包容量不超过v-c[i]时的最大价值加上第i件物品的价值，即`F[i][v] = F[i-1][v-c[i]] + w[i]`

但是从哪种状态转移过来的最大价值总更大呢，所以要对转移的状态进行比较，取更大的价值，因此得到状态转移方程如下：

```java
F[i][v] = max{F[i-1][v], F[i-1][v-c[i]] + w[i]};
```

这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。

现在，让我们来对所有的状态进行枚举，即通过遍历所有的物品和体积来找出最大价值总和，遍历顺序为第一层循环遍历所有的物品，第二层循环遍历背包容量，原因是要考虑取或不取第i件物品对体积的影响，如下：

```java
public int findMaxValue(int[] c, int[] w, int idx, int vol) {
    int[][] dp = new int[idx + 1][vol + 1];

    for (int i = 1; i <= idx; i++) {
        for (int v = 0; v <= vol; v++) {
            dp[i][v] = dp[i - 1][v];

            if (v >= c[i-1]) {
                dp[i][v] = Math.max(dp[i][v], dp[i-1][v - c[i-1]] + w[i-1]);
            }
        }
    }

    return dp[idx][vol];
}
```

接下来对上述方法的几点进行说明：

1. 为什么dp数组的长度为`idx+1`和`vol+1`？

	因为动态规划问题中的边界条件对结果的影响很大，因此需要留出空间对边界值进行赋值，而在背包问题中，不同的边界值可以产生不同的结果，下文会进行介绍。

2. 为什么最大值是`dp[idx][vol]`而不是`dp[idx][0...vol]`中的最大值呢？

	实际上这与我们对边界值的初始化有关，当把`F[0][0...vol]`都初始化为0时，所有`F[i][v]`中的值表示的是背包容量**不超过**v时的最大价值，即`dp[idx][vol]`可以由idx-1下体积不超过vol-w或vol时的最大价值转移而来；当把`F[0][0]`都初始化为0，而`F[0][1...vol]`都初始化为负无穷时，所有`F[i][v]`中的值表示的是背包容量**恰好为**v时的最大价值，即`dp[idx][vol]`只能由idx-1下体积恰好为vol-w或vol时的最大价值转移而来。

	我们也可以这样理解，如果要求背包恰好装满，那么没有物品可以选择的情况下，只有体积为0是满足恰好装满的并且此时的最大价值为0（`F[0][0]=0`），而其他体积是不可能达到的用负无穷表示（`F[0][0...val]=-INF`）；如果没有要求背包必须装满，那么没有物品可以选择的情况下，背包没有填满也是合法的且此时的最大价值为0（`F[0][0...val]=0`）。

	从数字层面来说，当i为1时，`dp[0][0...vol]`如果为0，那么`dp[1][0...vol]`在背包体积v大于物品体积的情况下一定为`w[i-1]`（dp在未初始化时默认所有值都为0，取最大值后一定为`w[i-1]`）；

